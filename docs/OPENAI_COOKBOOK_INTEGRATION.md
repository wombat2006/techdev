# OpenAI Cookbook Integration Guide

## üç≥ Overview

This guide integrates advanced techniques from the [OpenAI Cookbook](https://cookbook.openai.com) into TechSapo's architecture, filling gaps in our current implementation and enhancing AI capabilities.

## üìö Cookbook Topics Integration Status

### ‚úÖ Already Implemented in TechSapo

#### Embeddings & Vector Search
- **Current**: Advanced Japanese embedding service (`src/services/embedding-service.ts`)
- **Enhancement**: Multi-model comparison, caching, specialized term detection
- **Cookbook Value**: Advanced vector similarity algorithms, performance optimization

#### Multi-Agent Orchestration
- **Current**: Wall-Bounce Analyzer with multiple LLM providers
- **Enhancement**: OpenAI Agents SDK integration documented
- **Cookbook Value**: Advanced agent handoff patterns, tool orchestration

#### RAG (Retrieval Augmented Generation)
- **Current**: Google Drive integration for document retrieval
- **Enhancement**: Vector store optimization, semantic chunking
- **Cookbook Value**: Advanced retrieval strategies, context ranking

### ‚ùå Missing Critical Components

## üß† Context Management Implementation

### Context Trimming Strategy
```typescript
// Context management service for long conversations
export class ContextManager {
  private maxContextTokens: number = 8000; // GPT-5 context limit consideration
  private summaryTokens: number = 1000;

  async trimContext(conversation: ConversationMessage[]): Promise<ConversationMessage[]> {
    const totalTokens = this.estimateTokens(conversation);

    if (totalTokens <= this.maxContextTokens) {
      return conversation;
    }

    // Preserve system message and recent messages
    const systemMessages = conversation.filter(msg => msg.role === 'system');
    const recentMessages = conversation.slice(-10); // Keep last 10 messages
    const olderMessages = conversation.slice(0, -10).filter(msg => msg.role !== 'system');

    // Summarize older context
    const summary = await this.summarizeContext(olderMessages);

    return [
      ...systemMessages,
      {
        role: 'assistant',
        content: `[Context Summary] ${summary}`,
        timestamp: new Date().toISOString()
      },
      ...recentMessages
    ];
  }

  private async summarizeContext(messages: ConversationMessage[]): Promise<string> {
    const contextText = messages.map(msg => `${msg.role}: ${msg.content}`).join('\n');

    // Use wall-bounce for high-quality summarization
    const wallBounceResult = await wallBounceAnalyzer.executeWallBounce(
      `‰ª•‰∏ã„ÅÆ‰ºöË©±„ÇíÁ∞°ÊΩî„Å´Ë¶ÅÁ¥Ñ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÈáçË¶Å„Å™ÊäÄË°ìÊÉÖÂ†±„Å®Ëß£Ê±∫Á≠ñ„ÅØ‰øùÊåÅ„Åó„Å¶„Åè„Å†„Åï„ÅÑ:\n${contextText}`,
      'basic',
      { maxTokens: this.summaryTokens }
    );

    return wallBounceResult.consensus.content;
  }

  private estimateTokens(messages: ConversationMessage[]): number {
    return messages.reduce((total, msg) => {
      const japaneseChars = (msg.content.match(/[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9faf]/g) || []).length;
      const otherChars = msg.content.length - japaneseChars;
      return total + Math.ceil(japaneseChars * 1.5 + otherChars * 0.25);
    }, 0);
  }
}
```

### Conversation Memory System
```typescript
// Enhanced session management with conversation memory
export class ConversationMemoryManager {
  private redis: Redis;
  private contextManager: ContextManager;

  constructor(redis: Redis) {
    this.redis = redis;
    this.contextManager = new ContextManager();
  }

  async storeConversation(sessionId: string, message: ConversationMessage): Promise<void> {
    const conversation = await this.getConversation(sessionId);
    conversation.push(message);

    // Apply context management
    const trimmedConversation = await this.contextManager.trimContext(conversation);

    // Store with expiration
    await this.redis.setex(
      `conversation:${sessionId}`,
      86400, // 24 hours
      JSON.stringify({
        messages: trimmedConversation,
        lastActivity: new Date().toISOString(),
        totalMessages: conversation.length
      })
    );
  }

  async getConversationSummary(sessionId: string): Promise<ConversationSummary> {
    const conversation = await this.getConversation(sessionId);

    if (conversation.length === 0) {
      return {
        sessionId,
        totalMessages: 0,
        summary: 'Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥',
        keyTopics: [],
        lastActivity: new Date().toISOString()
      };
    }

    // Extract key topics using embeddings
    const topics = await this.extractKeyTopics(conversation);

    // Generate summary
    const summary = await this.contextManager.summarizeContext(conversation.slice(-20));

    return {
      sessionId,
      totalMessages: conversation.length,
      summary,
      keyTopics: topics,
      lastActivity: conversation[conversation.length - 1]?.timestamp || new Date().toISOString()
    };
  }

  private async extractKeyTopics(conversation: ConversationMessage[]): Promise<string[]> {
    const allText = conversation
      .map(msg => msg.content)
      .join(' ');

    // Use embedding service for topic extraction
    const embeddingService = new EmbeddingService(huggingFaceClient);
    const analysis = await embeddingService.analyzeWithMultipleModels({
      text: allText,
      options: { compareModels: true }
    });

    // Simple keyword extraction (could be enhanced with NER)
    const keywords = allText
      .match(/[„ÅÅ-„Çì„Ç°-„É∂„Éº‰∏Ä-Èæ†a-zA-Z0-9]+/g) || []
      .filter(word => word.length > 2)
      .reduce((counts, word) => {
        counts[word] = (counts[word] || 0) + 1;
        return counts;
      }, {} as Record<string, number>);

    return Object.entries(keywords)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([word]) => word);
  }
}

interface ConversationMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
  timestamp: string;
  metadata?: Record<string, any>;
}

interface ConversationSummary {
  sessionId: string;
  totalMessages: number;
  summary: string;
  keyTopics: string[];
  lastActivity: string;
}
```

## üé® Multimodal AI Integration

### Image Analysis for IT Support
```typescript
// Multimodal AI for screenshot analysis
export class MultimodalITAnalyzer {
  private openai: OpenAI;

  constructor(openai: OpenAI) {
    this.openai = openai;
  }

  async analyzeScreenshot(imageBuffer: Buffer, context: string): Promise<ITScreenshotAnalysis> {
    const base64Image = imageBuffer.toString('base64');

    // Use GPT-5 with vision capabilities
    const response = await this.openai.responses.create({
      model: 'gpt-5', // Assuming multimodal support
      instructions: `
        „ÅÇ„Å™„Åü„ÅØITÊîØÊè¥„ÅÆÂ∞ÇÈñÄÂÆ∂„Åß„Åô„ÄÇ„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà„ÇíÂàÜÊûê„Åó„Å¶‰ª•‰∏ã„ÇíÁâπÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ:
        1. „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆÂÜÖÂÆπ
        2. „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã„ÅÆË©ï‰æ°
        3. Êé®Â•®„Åï„Çå„ÇãËß£Ê±∫Á≠ñ
        4. Á∑äÊÄ•Â∫¶„É¨„Éô„É´
      `,
      input: `
        „Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà: ${context}

        Ê∑ª‰ªò„Åï„Çå„Åü„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà„ÇíÂàÜÊûê„Åó„ÄÅITÂïèÈ°å„ÅÆË®∫Êñ≠„Å®Ëß£Ê±∫Á≠ñ„ÇíÊèêÊ°à„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
        Áâπ„Å´Êó•Êú¨Ë™û„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÇÑUI„ÉÜ„Ç≠„Çπ„Éà„Å´Ê≥®ÊÑè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
      `,
      tools: [
        {
          type: 'function',
          function: {
            name: 'analyzeErrorMessage',
            description: '„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆË©≥Á¥∞ÂàÜÊûê',
            parameters: {
              type: 'object',
              properties: {
                errorType: { type: 'string' },
                severity: { type: 'string', enum: ['low', 'medium', 'high', 'critical'] },
                suggestedActions: { type: 'array', items: { type: 'string' } }
              }
            }
          }
        }
      ],
      // Note: Image input would be handled according to actual API specification
      attachments: [{
        type: 'image',
        data: base64Image
      }]
    });

    return {
      analysis: response.output_text,
      errorMessages: this.extractErrorMessages(response.output_text),
      severity: this.determineSeverity(response.output_text),
      recommendations: this.extractRecommendations(response.output_text),
      confidence: 0.85 // Would be calculated based on response quality
    };
  }

  private extractErrorMessages(analysis: string): string[] {
    const errorPatterns = [
      /„Ç®„É©„Éº[Ôºö:]\s*(.+?)(?=\n|$)/gi,
      /error[Ôºö:]?\s*(.+?)(?=\n|$)/gi,
      /Â§±Êïó[Ôºö:]\s*(.+?)(?=\n|$)/gi
    ];

    const errors: string[] = [];
    errorPatterns.forEach(pattern => {
      const matches = analysis.matchAll(pattern);
      for (const match of matches) {
        if (match[1]) errors.push(match[1].trim());
      }
    });

    return errors;
  }

  private determineSeverity(analysis: string): 'low' | 'medium' | 'high' | 'critical' {
    const criticalKeywords = ['„Ç∑„Çπ„ÉÜ„É†ÂÅúÊ≠¢', 'ÂÖ®ÂÅúÊ≠¢', 'critical', '„Éá„Éº„ÇøÊêçÂ§±'];
    const highKeywords = ['„Çµ„Éº„Éê„Éº„ÉÄ„Ç¶„É≥', '„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÈöúÂÆ≥', 'ÈáçË¶Å„Å™„Ç®„É©„Éº'];
    const mediumKeywords = ['„Ç®„É©„Éº', 'Ë≠¶Âëä', 'warning', 'Áï∞Â∏∏'];

    const lowerAnalysis = analysis.toLowerCase();

    if (criticalKeywords.some(keyword => lowerAnalysis.includes(keyword.toLowerCase()))) {
      return 'critical';
    }
    if (highKeywords.some(keyword => lowerAnalysis.includes(keyword.toLowerCase()))) {
      return 'high';
    }
    if (mediumKeywords.some(keyword => lowerAnalysis.includes(keyword.toLowerCase()))) {
      return 'medium';
    }

    return 'low';
  }

  private extractRecommendations(analysis: string): string[] {
    const recommendationPatterns = [
      /Êé®Â•®[Ôºö:]?\s*(.+?)(?=\n|$)/gi,
      /Ëß£Ê±∫Á≠ñ[Ôºö:]?\s*(.+?)(?=\n|$)/gi,
      /ÂØæÁ≠ñ[Ôºö:]?\s*(.+?)(?=\n|$)/gi,
      /Ê¨°„ÅÆÊâãÈ†Ü[Ôºö:]?\s*(.+?)(?=\n|$)/gi
    ];

    const recommendations: string[] = [];
    recommendationPatterns.forEach(pattern => {
      const matches = analysis.matchAll(pattern);
      for (const match of matches) {
        if (match[1]) recommendations.push(match[1].trim());
      }
    });

    return recommendations;
  }
}

interface ITScreenshotAnalysis {
  analysis: string;
  errorMessages: string[];
  severity: 'low' | 'medium' | 'high' | 'critical';
  recommendations: string[];
  confidence: number;
}
```

## üîí AI-Powered Security Scanning

### Code Security Analysis
```typescript
// AI-powered security vulnerability detection
export class AISecurityScanner {
  private wallBounceAnalyzer: WallBounceAnalyzer;

  constructor(wallBounceAnalyzer: WallBounceAnalyzer) {
    this.wallBounceAnalyzer = wallBounceAnalyzer;
  }

  async scanCodeForVulnerabilities(code: string, language: string): Promise<SecurityScanResult> {
    const securityPrompt = `
      ‰ª•‰∏ã„ÅÆ${language}„Ç≥„Éº„Éâ„Çí„Çª„Ç≠„É•„É™„ÉÜ„Ç£ËÑÜÂº±ÊÄß„ÅÆË¶≥ÁÇπ„Åã„ÇâÂàÜÊûê„Åó„Å¶„Åè„Å†„Åï„ÅÑ:

      1. SQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥
      2. XSS (Cross-Site Scripting)
      3. CSRF (Cross-Site Request Forgery)
      4. Ë™çË®º„ÉªË™çÂèØ„ÅÆÂïèÈ°å
      5. Ê©üÂØÜÊÉÖÂ†±„ÅÆÊºèÊ¥©„É™„Çπ„ÇØ
      6. ÂÖ•ÂäõÂÄ§Ê§úË®º„ÅÆ‰∏çÂÇô
      7. „Çª„Ç≠„É•„Ç¢„Åß„Å™„ÅÑÊöóÂè∑Âåñ

      „Ç≥„Éº„Éâ:
      \`\`\`${language}
      ${code}
      \`\`\`

      ÂêÑËÑÜÂº±ÊÄß„Å´„Å§„ÅÑ„Å¶„ÄÅ„É™„Çπ„ÇØ„É¨„Éô„É´ÔºàÈ´ò„Éª‰∏≠„Éª‰ΩéÔºâ„Å®ÂÖ∑‰ΩìÁöÑ„Å™‰øÆÊ≠£ÊèêÊ°à„ÇíÊèê‰æõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
    `;

    const analysis = await this.wallBounceAnalyzer.executeWallBounce(
      securityPrompt,
      'critical', // Use highest quality for security analysis
      {
        minProviders: 3,
        maxProviders: 4,
        confidenceThreshold: 0.9,
        requireConsensus: true
      }
    );

    return this.parseSecurityAnalysis(analysis.consensus.content, code, language);
  }

  async scanConfigForSecrets(configContent: string, filename: string): Promise<SecretScanResult> {
    // Pattern-based secret detection
    const secretPatterns = {
      api_key: /(?:api[_-]?key|apikey)[\s]*[:=][\s]*['""]?([a-zA-Z0-9_\-]{16,})['""]?/gi,
      jwt_token: /(?:jwt|token)[\s]*[:=][\s]*['""]?(eyJ[a-zA-Z0-9_\-\.]+)['""]?/gi,
      password: /(?:password|passwd|pwd)[\s]*[:=][\s]*['""]?([^'""\\s]{8,})['""]?/gi,
      database_url: /(?:database[_-]?url|db[_-]?url)[\s]*[:=][\s]*['""]?([^'""\\s]+)['""]?/gi,
      private_key: /(-----BEGIN\s+(?:RSA\s+)?PRIVATE\s+KEY-----[\s\S]*?-----END\s+(?:RSA\s+)?PRIVATE\s+KEY-----)/gi
    };

    const detectedSecrets: DetectedSecret[] = [];

    Object.entries(secretPatterns).forEach(([type, pattern]) => {
      const matches = configContent.matchAll(pattern);
      for (const match of matches) {
        if (match[1]) {
          detectedSecrets.push({
            type,
            value: match[1],
            line: this.getLineNumber(configContent, match.index || 0),
            severity: this.getSecretSeverity(type),
            recommendation: this.getSecretRecommendation(type)
          });
        }
      }
    });

    // AI-powered validation for potential false positives
    if (detectedSecrets.length > 0) {
      const validationPrompt = `
        ‰ª•‰∏ã„ÅÆ„Éï„Ç°„Ç§„É´„Äå${filename}„Äç„ÅßÊ§úÂá∫„Åï„Çå„ÅüÊΩúÂú®ÁöÑ„Å™Ê©üÂØÜÊÉÖÂ†±„ÇíÂàÜÊûê„Åó„Å¶„Åè„Å†„Åï„ÅÑ:

        ${detectedSecrets.map(secret =>
          `- ${secret.type}: ${secret.value.substring(0, 10)}... (Ë°å ${secret.line})`
        ).join('\n')}

        „Åù„Çå„Åû„Çå„Å´„Å§„ÅÑ„Å¶„ÄÅÂÆüÈöõ„ÅÆÊ©üÂØÜÊÉÖÂ†±„Åã„Å©„ÅÜ„Åã„ÄÅÂÅΩÈôΩÊÄß„ÅÆÂèØËÉΩÊÄß„ÄÅ„É™„Çπ„ÇØ„É¨„Éô„É´„ÇíË©ï‰æ°„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
      `;

      const aiValidation = await this.wallBounceAnalyzer.executeWallBounce(
        validationPrompt,
        'premium'
      );

      return {
        filename,
        detectedSecrets,
        aiValidation: aiValidation.consensus.content,
        recommendation: this.generateSecretScanRecommendation(detectedSecrets)
      };
    }

    return {
      filename,
      detectedSecrets: [],
      aiValidation: 'Ê©üÂØÜÊÉÖÂ†±„ÅØÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ',
      recommendation: '„Éï„Ç°„Ç§„É´„ÅØ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÉÅ„Çß„ÉÉ„ÇØ„Å´ÂêàÊ†º„Åó„Åæ„Åó„Åü„ÄÇ'
    };
  }

  private parseSecurityAnalysis(analysis: string, code: string, language: string): SecurityScanResult {
    const vulnerabilities: SecurityVulnerability[] = [];

    // Parse AI analysis for structured vulnerabilities
    const vulnerabilityTypes = [
      'SQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥', 'XSS', 'CSRF', 'Ë™çË®º', 'Ë™çÂèØ',
      'Ê©üÂØÜÊÉÖÂ†±ÊºèÊ¥©', 'ÂÖ•ÂäõÂÄ§Ê§úË®º', 'ÊöóÂè∑Âåñ'
    ];

    vulnerabilityTypes.forEach(type => {
      const typeRegex = new RegExp(`${type}[Ôºö:]?([\\s\\S]*?)(?=(?:${vulnerabilityTypes.join('|')})|$)`, 'i');
      const match = analysis.match(typeRegex);

      if (match && match[1] && match[1].includes('„É™„Çπ„ÇØ')) {
        const severity = this.extractSeverity(match[1]);
        const description = this.extractDescription(match[1]);
        const recommendation = this.extractRecommendation(match[1]);

        if (severity !== 'none') {
          vulnerabilities.push({
            type,
            severity,
            description,
            recommendation,
            lineNumbers: this.findRelevantLines(code, type)
          });
        }
      }
    });

    return {
      language,
      totalVulnerabilities: vulnerabilities.length,
      highRiskCount: vulnerabilities.filter(v => v.severity === 'high').length,
      mediumRiskCount: vulnerabilities.filter(v => v.severity === 'medium').length,
      lowRiskCount: vulnerabilities.filter(v => v.severity === 'low').length,
      vulnerabilities,
      overallRisk: this.calculateOverallRisk(vulnerabilities),
      recommendation: this.generateOverallRecommendation(vulnerabilities)
    };
  }

  private getSecretSeverity(secretType: string): 'high' | 'medium' | 'low' {
    const highRisk = ['api_key', 'private_key', 'jwt_token'];
    const mediumRisk = ['database_url', 'password'];

    if (highRisk.includes(secretType)) return 'high';
    if (mediumRisk.includes(secretType)) return 'medium';
    return 'low';
  }

  private getSecretRecommendation(secretType: string): string {
    const recommendations = {
      api_key: 'Áí∞Â¢ÉÂ§âÊï∞„ÇÑ„Ç∑„Éº„ÇØ„É¨„ÉÉ„ÉàÁÆ°ÁêÜ„Çµ„Éº„Éì„ÇπÔºàAWS Secrets ManagerÁ≠âÔºâ„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      jwt_token: 'JWT„Éà„Éº„ÇØ„É≥„ÅØÁí∞Â¢ÉÂ§âÊï∞„ÅßÁÆ°ÁêÜ„Åó„ÄÅÈÅ©Âàá„Å™ÊúâÂäπÊúüÈôê„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      password: '„Éë„Çπ„ÉØ„Éº„Éâ„ÅØÊöóÂè∑Âåñ„Åó„Å¶‰øùÂ≠ò„Åó„ÄÅ„Éó„É¨„Éº„É≥„ÉÜ„Ç≠„Çπ„Éà„Åß„ÅÆ‰øùÂ≠ò„ÇíÈÅø„Åë„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      database_url: '„Éá„Éº„Çø„Éô„Éº„ÇπÊé•Á∂öÊÉÖÂ†±„ÅØÁí∞Â¢ÉÂ§âÊï∞„ÇÑVault„ÅßÁÆ°ÁêÜ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      private_key: 'ÁßòÂØÜÈçµ„ÅØ„Çª„Ç≠„É•„Ç¢„Å™„Ç≠„Éº„Çπ„Éà„Ç¢„ÅßÁÆ°ÁêÜ„Åó„ÄÅÈÅ©Âàá„Å™Ê®©ÈôêË®≠ÂÆö„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
    };

    return recommendations[secretType as keyof typeof recommendations] ||
           'Ê©üÂØÜÊÉÖÂ†±„ÅØÈÅ©Âàá„Å™„Ç∑„Éº„ÇØ„É¨„ÉÉ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„Åß‰øùË≠∑„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
  }

  private getLineNumber(content: string, index: number): number {
    return content.substring(0, index).split('\n').length;
  }

  private extractSeverity(text: string): 'high' | 'medium' | 'low' | 'none' {
    if (/È´ò[„É™„Çπ„ÇØ|Âç±Èô∫]|critical|high/i.test(text)) return 'high';
    if (/‰∏≠[„É™„Çπ„ÇØ|Âç±Èô∫]|medium/i.test(text)) return 'medium';
    if (/‰Ωé[„É™„Çπ„ÇØ|Âç±Èô∫]|low/i.test(text)) return 'low';
    if (/„Å™„Åó|ÁÑ°„Åó|ÂïèÈ°å„Å™„Åó|no risk/i.test(text)) return 'none';
    return 'low'; // Default
  }

  private extractDescription(text: string): string {
    const descMatch = text.match(/Ë™¨Êòé[Ôºö:]?\s*(.+?)(?=Êé®Â•®|ÂØæÁ≠ñ|$)/s);
    return descMatch ? descMatch[1].trim() : text.substring(0, 200) + '...';
  }

  private extractRecommendation(text: string): string {
    const recMatch = text.match(/(?:Êé®Â•®|ÂØæÁ≠ñ|‰øÆÊ≠£)[Ôºö:]?\s*(.+?)$/s);
    return recMatch ? recMatch[1].trim() : 'Ë©≥Á¥∞„Å™ÂØæÁ≠ñ„Å´„Å§„ÅÑ„Å¶„ÅØÈñãÁô∫„ÉÅ„Éº„É†„Å®Áõ∏Ë´á„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
  }

  private findRelevantLines(code: string, vulnerabilityType: string): number[] {
    const lines: number[] = [];
    const codeLines = code.split('\n');

    // Simple heuristics for finding relevant lines
    const patterns = {
      'SQL„Ç§„É≥„Ç∏„Çß„ÇØ„Ç∑„Éß„É≥': /(?:query|sql|SELECT|INSERT|UPDATE|DELETE)/i,
      'XSS': /(?:innerHTML|document\.write|eval)/i,
      'CSRF': /(?:form|POST|PUT|DELETE)/i,
      'Ë™çË®º': /(?:auth|login|password|token)/i,
      'ÊöóÂè∑Âåñ': /(?:encrypt|decrypt|hash|md5|sha1)/i
    };

    const pattern = patterns[vulnerabilityType as keyof typeof patterns];
    if (pattern) {
      codeLines.forEach((line, index) => {
        if (pattern.test(line)) {
          lines.push(index + 1);
        }
      });
    }

    return lines;
  }

  private calculateOverallRisk(vulnerabilities: SecurityVulnerability[]): 'critical' | 'high' | 'medium' | 'low' {
    const highCount = vulnerabilities.filter(v => v.severity === 'high').length;
    const mediumCount = vulnerabilities.filter(v => v.severity === 'medium').length;

    if (highCount >= 3) return 'critical';
    if (highCount >= 1) return 'high';
    if (mediumCount >= 3) return 'high';
    if (mediumCount >= 1) return 'medium';
    return 'low';
  }

  private generateOverallRecommendation(vulnerabilities: SecurityVulnerability[]): string {
    if (vulnerabilities.length === 0) {
      return '„Ç≥„Éº„Éâ„Å´„Çª„Ç≠„É•„É™„ÉÜ„Ç£‰∏ä„ÅÆÂïèÈ°å„ÅØÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ';
    }

    const highRiskCount = vulnerabilities.filter(v => v.severity === 'high').length;

    if (highRiskCount > 0) {
      return `${highRiskCount}ÂÄã„ÅÆÈ´ò„É™„Çπ„ÇØËÑÜÂº±ÊÄß„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇÁõ¥„Å°„Å´‰øÆÊ≠£„Åô„Çã„Åì„Å®„ÇíÂº∑„ÅèÊé®Â•®„Åó„Åæ„Åô„ÄÇ`;
    } else {
      return '‰∏≠„Éª‰Ωé„É™„Çπ„ÇØ„ÅÆËÑÜÂº±ÊÄß„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇË®àÁîªÁöÑ„Å™‰øÆÊ≠£„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ';
    }
  }

  private generateSecretScanRecommendation(secrets: DetectedSecret[]): string {
    const highRiskCount = secrets.filter(s => s.severity === 'high').length;

    if (highRiskCount > 0) {
      return `${highRiskCount}ÂÄã„ÅÆÈ´ò„É™„Çπ„ÇØÊ©üÂØÜÊÉÖÂ†±„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇÁõ¥„Å°„Å´Áí∞Â¢ÉÂ§âÊï∞„ÇÑ„Ç∑„Éº„ÇØ„É¨„ÉÉ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„Å´ÁßªË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
    } else {
      return 'Ê©üÂØÜÊÉÖÂ†±„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇ„Çª„Ç≠„É•„É™„ÉÜ„Ç£„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ„Å´Âæì„Å£„Å¶‰øùË≠∑„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
    }
  }
}

// Type definitions
interface SecurityVulnerability {
  type: string;
  severity: 'high' | 'medium' | 'low';
  description: string;
  recommendation: string;
  lineNumbers: number[];
}

interface SecurityScanResult {
  language: string;
  totalVulnerabilities: number;
  highRiskCount: number;
  mediumRiskCount: number;
  lowRiskCount: number;
  vulnerabilities: SecurityVulnerability[];
  overallRisk: 'critical' | 'high' | 'medium' | 'low';
  recommendation: string;
}

interface DetectedSecret {
  type: string;
  value: string;
  line: number;
  severity: 'high' | 'medium' | 'low';
  recommendation: string;
}

interface SecretScanResult {
  filename: string;
  detectedSecrets: DetectedSecret[];
  aiValidation: string;
  recommendation: string;
}
```

## üöÄ Fine-tuning Integration

### Custom Model Training for IT Support
```typescript
// Fine-tuning service for domain-specific models
export class ITSupportFineTuningService {
  private openai: OpenAI;
  private trainingDataStore: Redis;

  constructor(openai: OpenAI, redis: Redis) {
    this.openai = openai;
    this.trainingDataStore = redis;
  }

  async collectTrainingData(interactions: ITSupportInteraction[]): Promise<void> {
    const trainingExamples = interactions
      .filter(interaction => interaction.resolved && interaction.quality_score >= 4.0)
      .map(interaction => this.formatTrainingExample(interaction));

    // Store training data for batch processing
    for (const example of trainingExamples) {
      await this.trainingDataStore.lpush(
        'fine_tuning:training_data',
        JSON.stringify(example)
      );
    }

    logger.info(`Collected ${trainingExamples.length} training examples`);
  }

  async createFineTuningJob(purpose: FineTuningPurpose): Promise<string> {
    // Retrieve training data
    const trainingData = await this.getTrainingData(purpose);

    if (trainingData.length < 100) {
      throw new Error(`Insufficient training data: ${trainingData.length} examples (minimum 100 required)`);
    }

    // Create training file
    const trainingFile = await this.openai.files.create({
      file: Buffer.from(trainingData.map(d => JSON.stringify(d)).join('\n')),
      purpose: 'fine-tune'
    });

    // Start fine-tuning job
    const fineTuningJob = await this.openai.fineTuning.jobs.create({
      training_file: trainingFile.id,
      model: 'gpt-5', // Base model - as per project requirements
      suffix: `techsapo-${purpose}`,
      hyperparameters: {
        n_epochs: 3,
        batch_size: 1,
        learning_rate_multiplier: 0.1
      }
    });

    // Store job information
    await this.trainingDataStore.hset(
      'fine_tuning:jobs',
      fineTuningJob.id,
      JSON.stringify({
        purpose,
        status: 'queued',
        created_at: new Date().toISOString(),
        training_examples: trainingData.length
      })
    );

    return fineTuningJob.id;
  }

  async monitorFineTuningJob(jobId: string): Promise<FineTuningStatus> {
    const job = await this.openai.fineTuning.jobs.retrieve(jobId);

    // Update status in Redis
    await this.trainingDataStore.hset(
      'fine_tuning:jobs',
      jobId,
      JSON.stringify({
        ...JSON.parse(await this.trainingDataStore.hget('fine_tuning:jobs', jobId) || '{}'),
        status: job.status,
        finished_at: job.finished_at ? new Date(job.finished_at * 1000).toISOString() : null,
        fine_tuned_model: job.fine_tuned_model
      })
    );

    return {
      id: job.id,
      status: job.status as 'queued' | 'running' | 'succeeded' | 'failed',
      progress: this.calculateProgress(job),
      model_name: job.fine_tuned_model,
      estimated_completion: job.estimated_finish ? new Date(job.estimated_finish * 1000) : null
    };
  }

  private formatTrainingExample(interaction: ITSupportInteraction): FineTuningExample {
    return {
      messages: [
        {
          role: 'system',
          content: `„ÅÇ„Å™„Åü„ÅØÊó•Êú¨Ë™ûITÊîØÊè¥„ÅÆÂ∞ÇÈñÄÂÆ∂„Åß„Åô„ÄÇÊäÄË°ìÁöÑÂïèÈ°å„ÇíÂàÜÊûê„Åó„ÄÅÊòéÁ¢∫„ÅßÂÆüË°åÂèØËÉΩ„Å™Ëß£Ê±∫Á≠ñ„ÇíÊèê‰æõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

          Â∞ÇÈñÄÂàÜÈáé:
          - „Ç∑„Çπ„ÉÜ„É†ÁÆ°ÁêÜ„Å®„Ç§„É≥„Éï„É©
          - „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Éà„É©„Éñ„É´„Ç∑„É•„Éº„ÉÜ„Ç£„É≥„Ç∞
          - „Éá„Éº„Çø„Éô„Éº„ÇπÂïèÈ°å
          - „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Ç®„É©„ÉºÂàÜÊûê
          - „Çª„Ç≠„É•„É™„ÉÜ„Ç£„Ç§„É≥„Ç∑„Éá„É≥„ÉàÂØæÂøú`
        },
        {
          role: 'user',
          content: interaction.user_query
        },
        {
          role: 'assistant',
          content: interaction.resolved_solution
        }
      ]
    };
  }

  private async getTrainingData(purpose: FineTuningPurpose): Promise<FineTuningExample[]> {
    const allData = await this.trainingDataStore.lrange('fine_tuning:training_data', 0, -1);
    const parsedData = allData.map(data => JSON.parse(data) as FineTuningExample);

    // Filter by purpose
    switch (purpose) {
      case 'log_analysis':
        return parsedData.filter(example =>
          example.messages.some(msg =>
            /„É≠„Ç∞|log|„Ç®„É©„Éº|error|ÈöúÂÆ≥/.test(msg.content.toLowerCase())
          )
        );
      case 'network_troubleshooting':
        return parsedData.filter(example =>
          example.messages.some(msg =>
            /„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ|network|Êé•Á∂ö|connection|ÈÄö‰ø°/.test(msg.content.toLowerCase())
          )
        );
      case 'security_analysis':
        return parsedData.filter(example =>
          example.messages.some(msg =>
            /„Çª„Ç≠„É•„É™„ÉÜ„Ç£|security|ÊîªÊíÉ|ËÑÜÂº±ÊÄß|vulnerability/.test(msg.content.toLowerCase())
          )
        );
      default:
        return parsedData;
    }
  }

  private calculateProgress(job: any): number {
    if (job.status === 'succeeded') return 100;
    if (job.status === 'failed') return 0;
    if (job.status === 'queued') return 0;

    // Rough estimation based on events
    const events = job.events || [];
    return Math.min(95, events.length * 10);
  }
}

// Type definitions
interface ITSupportInteraction {
  id: string;
  user_query: string;
  resolved_solution: string;
  resolved: boolean;
  quality_score: number; // 1-5 rating
  category: string;
  timestamp: string;
}

interface FineTuningExample {
  messages: Array<{
    role: 'system' | 'user' | 'assistant';
    content: string;
  }>;
}

interface FineTuningStatus {
  id: string;
  status: 'queued' | 'running' | 'succeeded' | 'failed';
  progress: number;
  model_name: string | null;
  estimated_completion: Date | null;
}

type FineTuningPurpose = 'log_analysis' | 'network_troubleshooting' | 'security_analysis' | 'general_support';
```

## üéØ Integration with Existing TechSapo Systems

### Enhanced Wall-Bounce with Cookbook Techniques
```typescript
// Enhanced wall-bounce analyzer with cookbook integration
export class CookbookEnhancedWallBounceAnalyzer extends WallBounceAnalyzer {
  private contextManager: ContextManager;
  private conversationMemory: ConversationMemoryManager;
  private securityScanner: AISecurityScanner;
  private multimodalAnalyzer: MultimodalITAnalyzer;

  constructor() {
    super();
    this.contextManager = new ContextManager();
    this.conversationMemory = new ConversationMemoryManager(getRedisService());
    this.securityScanner = new AISecurityScanner(this);
    this.multimodalAnalyzer = new MultimodalITAnalyzer(openai);
  }

  async executeEnhancedWallBounce(
    query: string,
    taskType: TaskType,
    options: EnhancedWallBounceOptions = {}
  ): Promise<EnhancedWallBounceResult> {
    // Context management for long conversations
    let processedQuery = query;
    if (options.sessionId) {
      const conversationContext = await this.conversationMemory.getConversation(options.sessionId);
      if (conversationContext.length > 5) {
        const trimmedContext = await this.contextManager.trimContext(conversationContext);
        const contextSummary = trimmedContext
          .filter(msg => msg.role === 'assistant' && msg.content.includes('[Context Summary]'))
          .map(msg => msg.content)
          .join('\n');

        processedQuery = `${contextSummary}\n\nÁèæÂú®„ÅÆË≥™Âïè: ${query}`;
      }
    }

    // Enhanced analysis with multimodal support
    let multimodalAnalysis: ITScreenshotAnalysis | undefined;
    if (options.imageBuffer) {
      multimodalAnalysis = await this.multimodalAnalyzer.analyzeScreenshot(
        options.imageBuffer,
        processedQuery
      );
      processedQuery += `\n\nÁîªÂÉèËß£ÊûêÁµêÊûú:\n${multimodalAnalysis.analysis}`;
    }

    // Security scanning if code is provided
    let securityAnalysis: SecurityScanResult | undefined;
    if (options.codeContent && options.language) {
      securityAnalysis = await this.securityScanner.scanCodeForVulnerabilities(
        options.codeContent,
        options.language
      );

      if (securityAnalysis.totalVulnerabilities > 0) {
        processedQuery += `\n\n„Çª„Ç≠„É•„É™„ÉÜ„Ç£ÂàÜÊûêÁµêÊûú:\n${securityAnalysis.recommendation}`;
      }
    }

    // Execute enhanced wall-bounce analysis
    const wallBounceResult = await super.executeWallBounce(
      processedQuery,
      taskType,
      {
        ...options,
        confidenceThreshold: options.confidenceThreshold || 0.8,
        requireConsensus: true
      }
    );

    // Store conversation if session provided
    if (options.sessionId) {
      await this.conversationMemory.storeConversation(options.sessionId, {
        role: 'user',
        content: query,
        timestamp: new Date().toISOString()
      });

      await this.conversationMemory.storeConversation(options.sessionId, {
        role: 'assistant',
        content: wallBounceResult.consensus.content,
        timestamp: new Date().toISOString(),
        metadata: {
          confidence: wallBounceResult.consensus.confidence,
          providers_used: wallBounceResult.debug.providers_used,
          has_multimodal: !!multimodalAnalysis,
          has_security_scan: !!securityAnalysis
        }
      });
    }

    return {
      ...wallBounceResult,
      enhancements: {
        multimodal_analysis: multimodalAnalysis,
        security_analysis: securityAnalysis,
        context_managed: !!options.sessionId,
        conversation_summary: options.sessionId ?
          await this.conversationMemory.getConversationSummary(options.sessionId) : undefined
      }
    };
  }
}

interface EnhancedWallBounceOptions extends WallBounceOptions {
  sessionId?: string;
  imageBuffer?: Buffer;
  codeContent?: string;
  language?: string;
}

interface EnhancedWallBounceResult extends WallBounceResult {
  enhancements: {
    multimodal_analysis?: ITScreenshotAnalysis;
    security_analysis?: SecurityScanResult;
    context_managed: boolean;
    conversation_summary?: ConversationSummary;
  };
}
```

## üìä Integration Roadmap

### Phase 1: Core Context Management (Week 1-2)
- [ ] Implement ContextManager service
- [ ] Enhance ConversationMemoryManager
- [ ] Integrate with existing session management
- [ ] Add context trimming to wall-bounce analyzer

### Phase 2: Security Enhancement (Week 3-4)
- [ ] Implement AISecurityScanner
- [ ] Add secret detection capabilities
- [ ] Integrate security scanning into CI/CD pipeline
- [ ] Create security dashboard

### Phase 3: Multimodal Capabilities (Week 5-6)
- [ ] Implement MultimodalITAnalyzer
- [ ] Add screenshot analysis API endpoints
- [ ] Enhance error detection with vision
- [ ] Create multimodal UI components

### Phase 4: Fine-tuning Integration (Week 7-8)
- [ ] Implement ITSupportFineTuningService
- [ ] Create training data collection pipeline
- [ ] Set up model versioning and deployment
- [ ] Monitor fine-tuned model performance

### Phase 5: Full Integration (Week 9-10)
- [ ] Integrate all cookbook techniques with wall-bounce
- [ ] Comprehensive testing and quality assurance
- [ ] Performance optimization
- [ ] Documentation and training

## üîß Configuration Updates

### Environment Variables
```bash
# Context Management
CONTEXT_MAX_TOKENS=8000
CONTEXT_SUMMARY_TOKENS=1000
CONVERSATION_MEMORY_TTL=86400

# Multimodal Analysis
MULTIMODAL_ANALYSIS_ENABLED=true
MAX_IMAGE_SIZE_MB=10
SUPPORTED_IMAGE_FORMATS=png,jpg,jpeg,gif

# Security Scanning
SECURITY_SCANNING_ENABLED=true
SECRET_DETECTION_ENABLED=true
VULNERABILITY_THRESHOLD=medium

# Fine-tuning
FINE_TUNING_ENABLED=false
MIN_TRAINING_EXAMPLES=100
FINE_TUNING_BUDGET_LIMIT=100.00
```

### Monitoring Integration
```typescript
// Additional Prometheus metrics for cookbook features
const cookbookMetrics = {
  context_trimming_operations: new prometheus.Counter({
    name: 'techsapo_context_trimming_total',
    help: 'Number of context trimming operations performed'
  }),

  security_scans_performed: new prometheus.Counter({
    name: 'techsapo_security_scans_total',
    help: 'Number of security scans performed',
    labelNames: ['scan_type', 'result']
  }),

  multimodal_analyses: new prometheus.Counter({
    name: 'techsapo_multimodal_analyses_total',
    help: 'Number of multimodal analyses performed',
    labelNames: ['content_type']
  }),

  fine_tuning_jobs: new prometheus.Gauge({
    name: 'techsapo_fine_tuning_jobs_active',
    help: 'Number of active fine-tuning jobs'
  })
};
```

## üéØ Success Metrics

### Quality Improvements
- **Context Retention**: 90%+ context relevance in long conversations
- **Security Detection**: 95%+ vulnerability detection accuracy
- **Multimodal Analysis**: 85%+ screenshot problem identification
- **Fine-tuned Performance**: 20%+ improvement in domain-specific responses

### Performance Targets
- **Context Trimming**: < 500ms processing time
- **Security Scanning**: < 2s for code analysis
- **Multimodal Analysis**: < 5s for screenshot analysis
- **Memory Overhead**: < 15% increase in base memory usage

This comprehensive integration brings OpenAI Cookbook's advanced techniques into TechSapo's architecture while maintaining compatibility with existing systems and requirements.